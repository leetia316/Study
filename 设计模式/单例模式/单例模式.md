<center><h1><i style="color:red">单例模式</i></h1></center>

### 定义: <u>保证一个类仅有一个实例，并提供一个访问它的全局访问点</u>

### 动机：
  对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。

### 优缺点:
  * 优点：
    1. 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例
    2. 因为类控制了实例化过程，所以类可以灵活更改实例化过程
    3. 在内存里只有一个实例，减少了内存的开销
    4. 避免对资源的多重占用
  * 缺点：
    1. 虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销(可以通过使用静态初始化解决此问题)

### 构建思路：
  * 使用该单例对象时判断系统是否已经有这个单例对象，如果有就返回，如果没有就创建

## 构建示例：

* 示例1

>私有构造函数（避免直接访问构造函数来创建实例）

``````js
let SingletonInterface = (function () {
  //私有构造器
  function Singleton() {
    this.meg = "Hello!"
  }

  //实例容器
  let instance

  //暴露出一个访问点
  return {
    getInstance: function() {
      if(instance === undefined) {
        instance = new Singleton()
      }
      return instance
    }
  }
})()

let singleton = SingletonInterface.getInstance()
console.log(singleton.meg) // Hello!
let singleton2 = SingletonInterface.getInstance()
console.log(singleton === singleton2) // true
``````

* 示例2

>构造器内部判断（若实例存在则停止构造返回实例，若不存在则继续构造）

``````js
function Singleton() {
  //判断是否存在实例
  if(typeof Singleton.instance === 'object') {
    return Singleton.instance
  }

  this.msg = "Hello!"

  //实例容器
   Singleton.instance = this
}

let singleton = new Singleton()
console.log(singleton.msg) // Hello!
let singleton2 = new Singleton()
console.log(singleton === singleton2) // true
``````

* 示例3

>重写构造函数（第一次构建实例时重写构造函数，功能为直接返回实例）

``````js
function Singleton() {
  //实例容器
  let instance = this

  this.msg = "Hello!"

  //重写构造函数
  Singleton = function () {
    return instance
  }
}
let singleton = new Singleton()
console.log(singleton.msg) // Hello!
let singleton2 = new Singleton()
console.log(singleton === singleton2) // true
``````

>提一下new关键字的作用:1.创建一个新的空的对象 2.为新对象绑定原型 3.将构造函数this指向新对象并执行 4.让构造函数返回新对象

